<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--------------------------------------------------------------------------->  
<!--                           INTRODUCTION                                

 The Code Project article submission template (HTML version)

Using this template will help us post your article sooner. To use, just 
follow the 3 easy steps below:
 
     1. Fill in the article description details
     2. Add links to your images and downloads
     3. Include the main article text

That's all there is to it! All formatting will be done by our submission
scripts and style sheets. 

-->  
<!--------------------------------------------------------------------------->  
<!--                        IGNORE THIS SECTION                            -->
<html>
<head>
<title>The Code Project</title>
<Style>
BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
H2 { font-size: 13pt; }
H3 { font-size: 12pt; }
H4 { font-size: 10pt; color: black; }
PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
</style>
<link rel="stylesheet" type="text/css" href="http://www.codeproject.com/App_Themes/NetCommunity/CodeProject.css">
</head>
<body bgcolor="#FFFFFF" color=#000000>
<!--------------------------------------------------------------------------->  


<!-------------------------------     STEP 1      --------------------------->
<!--  Fill in the details (CodeProject will reformat this section for you) -->

<pre>
Title:       NMoneys Part III, Show Me the Money
Author:      dgon
Email:       dgon_rena@hotmail.com
Language:    C#
Platform:    .NET Framework
Technology:  Libraries
Level:       Intermediate
Description: NMoneys is an implementation of the Money Value Object to support representing moneys in the currencies defined in the ISO 4417 standard
for the .NET platform. In this part, usage scenarios of the Money class will be showcased.
Section      Platforms, Frameworks & Libraries
SubSection   .NET Framework
License:     CPOL
</pre>

<!-------------------------------     STEP 2      --------------------------->
<!--  Include download and sample image information.                       --> 

<ul class="download">
<li><a href="NMoneys_III_src.zip">Download source - XXX Kb</a></li>
<li><a href="NMoneys_demo.zip">Download demo project - XXX Kb </a></li>
</ul>

<p><img src="NMoneys_long.png" alt="Sample Image - maximum width is 600 pixels"></p>


<!-------------------------------     STEP 3      --------------------------->

<!--  Add the article text. Please use simple formatting (<h2>, <p> etc)   -->

<h2>Introduction</h2>

<p>In the previous part, one of the cornerstones of <a href="http://code.google.com/p/nmoneys/">NMoneys</a>, the <code>Currency</code> class, was analyzed and 
its set of features was shown. Now it is the turn of, probably, the most useful part of the library: the <code>Money</code> class.</p>

<h2>Using the code</h2>

<p>I am a strong believer that expressive unit tests are the best for of documentation that exists. I also think they are as good as any other way of
driving this series of articles. Hence, all the code I will be showing are unit tests that show off the abilities of
<a href="http://code.google.com/p/nmoneys/">NMoneys</a>. Those unit tests are <a href="http://www.nunit.com/">NUnit</a> tests and can be executed by
your favorite test runner.</p>
<p>Each snippet will be included in the source code download for the part.</p>
<p>On top of the code for each part of the series a "demo" project that contains the Visual Studio 2010 project (.NET 4.0) with all the tests will be included.</p>

<h2>Moneys</h2>
<p><code>Currency</code> implements the behaviors of a given currency, mainly formatting. But 
	this series started mentioning that the
.NET Framework already has mechanism for formatting, but it lacks of a way to univocally represent a monetary quantity in a given currency, differentiating it from another
quantity in another quantity.</p>
<p>Such representation is the <code>Money</code> structure.</p>
<h3>Obtain an instance</h3>
<p>As opposed to <code>Currency</code>, which only offered a limited number of instances to be created, there can be many instances of <code>Money</code> around. It follows
the semantics of numeric types and as such it has been implemented as struct, instead of a reference type. Most common way of obtaining an instance is using one of its
multiple constructors.
</p>
<pre lang="C#">
[Test]
public void a_Money_represents_a_monetary_quantity()
{
    new Money(10m, Currency.Dollar);        // Money --&gt; tenDollars
    new Money(2.5m, CurrencyIsoCode.EUR);   // Money --&gt; twoFiftyEuros
    new Money(10m, &quot;JPY&quot;);        // Money --&gt; tenYen
    new Money();                            // Money --&gt; zeroWithNoCurrency
}
</pre>
<p>One of the reasons of NMoneys to exist was the mix of concepts that the .NET Framework offers for formatting numbers and culture and language of the system.
To avoid surprises interactions with the environment (such as the current culture) are made explicit. In the following snippet the NUnit attribute
<code>SetCultureAttribute</code> is used to control which culture the test is run under (in this case is Danish).</p>
<pre lang="C#">
[Test, SetCulture(&quot;da-DK&quot;)]
public void environment_dependencies_are_explicit()
{
    Money fiveKrona = Money.ForCurrentCulture(5m);
    Assert.That(fiveKrona.CurrencyCode, Is.EqualTo(CurrencyIsoCode.DKK));

    Money currencyLessMoney = new Money(1);
    Assert.That(currencyLessMoney.CurrencyCode, Is.EqualTo(CurrencyIsoCode.XXX));

    Money zeroEuros = Money.ForCulture(0m, CultureInfo.GetCultureInfo(&quot;es-ES&quot;));
    Assert.That(zeroEuros.CurrencyCode, Is.EqualTo(CurrencyIsoCode.EUR));
}</pre>
<p>There is another way to create money instances: using a set of extension methods for brevity. The main scenario for this way of creating instances is unit testing.
When testing, a short an expressive to create objects for your scenarios is a big help.</p>
<pre lang="C#">
[Test]
public void moneys_can_be_quickly_created_for_testing_scenarios_with_extension_methods()
{
    // Money --&gt; threeNoCurrencies
    3m.Xxx();
    3m.ToMoney();

    // Money --&gt; threeAndAHalfAustralianDollars
    3.5m.Aud();
    3.5m.ToMoney(Currency.Aud);
    3.5m.ToMoney(CurrencyIsoCode.AUD);
    CurrencyIsoCode.AUD.ToMoney(3.5m);
}
</pre>
<p>A special case of instance creation are zero quantities.</p>
<pre lang="C#">
[Test]
public void when_you_money_worths_nothing()
{
    Money.Zero();
    Money.Zero(Currency.Usd);
    Money.Zero(CurrencyIsoCode.USD);
    Money.Zero(&quot;USD&quot;);
}
</pre>
<h3>Parsing</h3>
<p>Yet another way to create instances of <code>Money</code> is to parse a given string. This feature is only so useful, because the expected currency of the input needs to
be passed beforehand, since there are many currencies that use the same display symbol.</p>
<pre lang="C#">
[Test]
public void moneys_can_be_parsed_to_a_known_currency()
{
    Assert.That(Money.Parse(&quot;$1.5&quot;, Currency.Dollar), isMoneyWith(1.5m, CurrencyIsoCode.USD), &quot;one-and-the-half dollars&quot;);
    Assert.That(Money.Parse(&quot;10 &#8364;&quot;, Currency.Euro), isMoneyWith(10m, CurrencyIsoCode.EUR), &quot;ten euros&quot;);

    Assert.That(Money.Parse(&quot;kr -100&quot;, Currency.Dkk), isMoneyWith(-100m, CurrencyIsoCode.DKK), &quot;owe hundrede kroner&quot;);
    Assert.That(Money.Parse(&quot;(&#164;1.2)&quot;, Currency.None), isMoneyWith(-1.2m, CurrencyIsoCode.XXX), &quot;owe one point two, no currency&quot;);
}
</pre>
<p>On the other hand, the format of the number is pretty permissive. Formats that are not the one of the currency are successfully parsed.</p>
<pre lang="C#">
[Test]
public void number_formatting_is_flexible_for_parsing_purposes()
{
    Assert.That(Money.Parse(&quot;(&#8364;1.5)&quot;, Currency.Euro), isMoneyWith(-15m, CurrencyIsoCode.EUR), &quot;dollar style&quot;);
    Assert.That(Money.Parse(&quot;-&#8364;5,75&quot;, Currency.Euro), isMoneyWith(-5.75m, CurrencyIsoCode.EUR), &quot;pound style&quot;);
    Assert.That(Money.Parse(&quot;-10&quot;, Currency.Euro), isMoneyWith(-10m, CurrencyIsoCode.EUR), &quot;negative euro style without no symbol&quot;);
    Assert.That(Money.Parse(&quot;(1.2)&quot;, Currency.Euro), isMoneyWith(-12m, CurrencyIsoCode.EUR), &quot;negative dollar style with no symbol&quot;);
}
</pre>
<p>But still, the currencies have to be compatible with the input.</p>
<pre lang="C#">
[Test]
public void currencies_have_to_be_compatible_for_parsing()
{
    Assert.That(() =&gt; Money.Parse(&quot;($1.5)&quot;, Currency.Eur), Throws.InstanceOf&lt;FormatException&gt;(), &quot;currency not compatible&quot;);
    Assert.That(() =&gt; Money.Parse(&quot;notAMonetaryQuantity&quot;, Currency.Eur), Throws.InstanceOf&lt;FormatException&gt;());
    Assert.That(() =&gt; Money.Parse(&quot;1-e1&quot;, Currency.Eur), Throws.InstanceOf&lt;FormatException&gt;(), &quot;wrong format&quot;);
    Assert.That(() =&gt; Money.Parse(&quot;1--&quot;, Currency.Eur), Throws.InstanceOf&lt;FormatException&gt;());
}
</pre>
<h3>Major and minor units</h3>
<p>It is very common amongst currencies to have a major unit and a minor one. One clear example is, amongst others, the Sterling Pound. With that currency, the major unit is
the pound itself, whereas the minor unit is the penny.</p>
<p>For such common scenario there is a way to create money instances based on the amount of the major unit.</p>
<pre lang="C#">
[Test]
public void what_is_with_this_Major_thing()
{
    Assert.That(Money.ForMajor(234, Currency.Gbp), isMoneyWith(234, CurrencyIsoCode.GBP),
        &quot;instance created from the major units, in this case the Pound&quot;);

    Assert.That(3m.Pounds().MajorAmount, Is.EqualTo(3m), &quot;for whole amounts is the quantity&quot;);
    Assert.That(3.7m.Pounds().MajorAmount, Is.EqualTo(3m), &quot;for fractional amounts is the number of pounds&quot;);
    Assert.That(0.7m.Pounds().MajorAmount, Is.EqualTo(0m), &quot;for fractional amounts is the number of pounds&quot;);

    Assert.That(3m.Pounds().MajorIntegralAmount, Is.EqualTo(3L), &quot;for whole amounts is the non-fractional quantity&quot;);
    Assert.That(3.7m.Pounds().MajorIntegralAmount, Is.EqualTo(3L), &quot;for fractional amounts is the number of pounds&quot;);
    Assert.That(0.7m.Pounds().MajorIntegralAmount, Is.EqualTo(0L), &quot;for fractional amounts is the number of pounds&quot;);
}
</pre>
<p>And a way to create instances based on the amount of the minor unit.</p>
<pre lang="C#">
[Test]
public void what_is_with_this_Minor_thing()
{
    Assert.That(Currency.Pound.SignificantDecimalDigits, Is.EqualTo(2), &quot;pounds have pence, which is a hundreth of the major unit&quot;);

    Assert.That(Money.ForMinor(234, Currency.Gbp), isMoneyWith(2.34m, CurrencyIsoCode.GBP),
        &quot;234 pence is 2.34 pounds&quot;);
    Assert.That(Money.ForMinor(50, Currency.Gbp), isMoneyWith(0.5m, CurrencyIsoCode.GBP),
        &quot;fifty pence is half a pound&quot;);
    Assert.That(Money.ForMinor(-5, Currency.Gbp), isMoneyWith(-0.05m, CurrencyIsoCode.GBP),
        &quot;you owe me five pence, but keep them&quot;);

    Assert.That(3m.Pounds().MinorAmount, Is.EqualTo(300m), &quot;three pounds is 300 pence&quot;);
    Assert.That(.07m.Pounds().MinorAmount, Is.EqualTo(7m), &quot;for fractional amounts, the minor unit prevails&quot;);
    Assert.That(0.072m.Pounds().MinorAmount, Is.EqualTo(7m), &quot;tenths of pence are discarded&quot;);

    Assert.That(3m.Pounds().MinorIntegralAmount, Is.EqualTo(300L), &quot;three pounds is 300 pence&quot;);
    Assert.That(.07m.Pounds().MinorIntegralAmount, Is.EqualTo(7L), &quot;for fractional amounts, the minor unit prevails&quot;);
    Assert.That(0.072m.Pounds().MinorIntegralAmount, Is.EqualTo(7L), &quot;tenths of pence are discarded&quot;);
}
</pre>
<p>Some currencies adopt the schema of having a minor unit which is the hundredth of the major unit. In other currencies, minor units are the thousandth of the major unit.
And other currencies have no minor units at all.</p>
<pre lang="C#">
[Test]
public void some_currencies_are_divided_into_more_than_100_units()
{
    Currency dinar = Currency.Get(CurrencyIsoCode.BHD);
    Assert.That(dinar.SignificantDecimalDigits, Is.EqualTo(3), &quot;one dinar is 1000 fils&quot;);

    Assert.That(Money.ForMinor(2340, dinar), isMoneyWith(2.34m, CurrencyIsoCode.BHD),
        &quot;2340 fils is 2.34 dinar&quot;);
    Assert.That(Money.ForMinor(500, dinar), isMoneyWith(0.5m, CurrencyIsoCode.BHD),
        &quot;fifty fils is half a dinar&quot;);
    Assert.That(Money.ForMinor(-5, dinar), isMoneyWith(-0.005m, CurrencyIsoCode.BHD),
        &quot;you owe me five fils, but keep them&quot;);

    Assert.That(3m.ToMoney(dinar).MinorIntegralAmount, Is.EqualTo(3000L), &quot;three dinar is 3000 fils&quot;);
    Assert.That(.007m.ToMoney(dinar).MinorIntegralAmount, Is.EqualTo(7L), &quot;for fractional amounts, the minor unit prevails&quot;);
    Assert.That(0.0072m.ToMoney(dinar).MinorIntegralAmount, Is.EqualTo(7L), &quot;tenths of fil are discarded&quot;);
}

[Test]
public void and_some_currencies_do_not_have_minor_units()
{
    Currency yen = Currency.Get(CurrencyIsoCode.JPY);
    Assert.That(yen.SignificantDecimalDigits, Is.EqualTo(0), &quot;a yen is a yen is a yen&quot;);

    Assert.That(Money.ForMinor(2340, yen), isMoneyWith(2340m, CurrencyIsoCode.JPY),
        &quot;2340 yen are, well, 2340 yen&quot;);
    Assert.That(Money.ForMinor(-5, yen), isMoneyWith(-5m, CurrencyIsoCode.JPY),
        &quot;you owe me five yen, but keep them&quot;);

    Assert.That(3m.ToMoney(yen).MinorIntegralAmount, Is.EqualTo(3L), &quot;three dinar is three yen&quot;);
    Assert.That(3.7m.ToMoney(yen).MinorIntegralAmount, Is.EqualTo(3L), &quot;for fractional amounts, decimals are discarded&quot;);
    Assert.That(0.72m.ToMoney(yen).MinorIntegralAmount, Is.EqualTo(0L), &quot;less than a unit is not enough&quot;);
}
</pre>
<h3>What's in a money</h3>
<p>We have seen how a <code>Money</code> instance can be created. Why would anyone instantiate it? Is it for the data it provides?</p>
<pre lang="C#">
[Test]
public void what_is_in_a_money()
{
    Money threeCads = new Money(3m, &quot;CAD&quot;);

    Assert.That(threeCads.Amount, Is.EqualTo(3m));
    Assert.That(threeCads.CurrencyCode, Is.EqualTo(CurrencyIsoCode.CAD));
    Assert.That(threeCads.HasDecimals, Is.False);
    Assert.That(threeCads.IsNegative(), Is.False);
    Assert.That(threeCads.IsNegativeOrZero(), Is.False);
    Assert.That(threeCads.IsPositive(), Is.True);
    Assert.That(threeCads.IsPositiveOrZero(), Is.True);
    Assert.That(threeCads.IsZero(), Is.False);
}</pre>
<p>That, and the information about major and minor amounts is all interesting stuff. But... I am sure people want to do things with their money.</p>
<h3>What to do with money?</h3>
<p>That is an interesting question. But for the sake of this article, the answer will be focused towards the behaviors of <code>Money</code> objects.</p>
<p>To start with, being quantities of some kind, it makes a lot of sense that moneys can be compared. Otherwise, bragging about how red is our bank account would be impossible...</p>
<pre lang="C#">
[Test]
public void moneys_can_be_compared()
{
    Assert.That(3m.Usd().Equals(CurrencyIsoCode.USD.ToMoney(3m)), Is.True);
    Assert.That(3m.Usd() != CurrencyIsoCode.USD.ToMoney(3m), Is.False);
    Assert.That(3m.Usd().CompareTo(CurrencyIsoCode.USD.ToMoney(5m)), Is.LessThan(0));
    Assert.That(3m.Usd() &lt; CurrencyIsoCode.USD.ToMoney(5m), Is.True);
}
</pre>
<p>But (there is always one of those), instances of different currencies cannot be measured against each other blindly, just as "planes" cannot be compared to "apples"
(at least for most useful purposes). And since none of the goals of NMoneys is providing rate exchange services, moneys with different currencies simply cannot be compared.</p>
<pre lang="C#">
[Test]
public void comparisons_only_possible_if_they_have_the_same_currency()
{
    Assert.That(3m.Usd().Equals(3m.Gbp()), Is.False);
    Assert.That(3m.Usd() != CurrencyIsoCode.GBP.ToMoney(3m), Is.True);

    Assert.That(() =&gt; 3m.Usd().CompareTo(CurrencyIsoCode.GBP.ToMoney(5m)), Throws.InstanceOf&lt;DifferentCurrencyException&gt;());
    Assert.That(() =&gt; 3m.Usd() &lt; CurrencyIsoCode.GBP.ToMoney(5m), Throws.InstanceOf&lt;DifferentCurrencyException&gt;());
}</pre>
<p>One of the main reasons of existence of this library was to provide formatting and displaying features to monetary quantities, so it will not come as a surprise that
moneys can be displayed in various ways.</p>
<pre lang="C#">
[Test]
public void moneys_are_to_be_displayed()
{
    Assert.That(10.536m.Eur().ToString(), Is.EqualTo(&quot;10,54 &#8364;&quot;), &quot;default currency formatting according to instance's currency&quot;);
    Assert.That(3.2m.Usd().ToString(&quot;N&quot;), Is.EqualTo(&quot;3.20&quot;), &quot;alternative formatting according to instance's currency&quot;);
}
</pre>
<p>A common scenario is currencies that are used in different countries, and those countries have different ways of representing monetary quantities. That common scenario is
covered by using a different format provider than the one provided by the currency of the instance.</p>
<pre lang="C#">
[Test]
public void using_different_styles_for_currencies_taht_span_multiple_countries()
{
    Assert.That(3000.5m.Eur().ToString(), Is.EqualTo(&quot;3.000,50 &#8364;&quot;), &quot;default euro formatting&quot;);

    // in French the group separator is neither the dot or the space
    CultureInfo french = CultureInfo.GetCultureInfo(&quot;fr-FR&quot;);
    string threeThousandAndTheHaldInFrench = string.Format(&quot;3{0}000,50 &#8364;&quot;, french.NumberFormat.CurrencyGroupSeparator);
    Assert.That(3000.5m.Eur().ToString(french), Is.EqualTo(threeThousandAndTheHaldInFrench));
}
</pre>
<p>Richer formatting capabilities are also possible.</p>
<pre lang="C#">
[Test]
public void more_complex_formatting()
{
    Assert.That(3m.Usd().Format(&quot;{0:00.00} {2}&quot;), Is.EqualTo(&quot;03.00 USD&quot;), &quot;formatting placeholders for code and amount&quot;);
    Assert.That(2500m.Eur().Format(&quot;&gt; {1} {0:#,#.00}&quot;), Is.EqualTo(&quot;&gt; &#8364; 2.500,00&quot;), &quot;rich amount formatting&quot;);
}
</pre>
<p>Displaying moneys is important, but another very important thing one needs to do with a monetary quantity is performing some arithmetic operations.</p>
<pre lang="C#">
[Test]
public void moneys_are_to_be_operated_with_arithmetic_operators()
{
    Money fivePounds = 2m.Pounds().Plus(3m.Pounds());
    Assert.That(fivePounds, isMoneyWith(5m, CurrencyIsoCode.GBP));

    Money fiftyPence = 3m.Pounds() - 2.5m.Pounds();
    Assert.That(fiftyPence, isMoneyWith(.5m, CurrencyIsoCode.GBP));

    Money youOweMeThreeEuros = -3m.Eur();
    Assert.That(youOweMeThreeEuros, isMoneyWith(-3m, CurrencyIsoCode.EUR));

    Money nowIHaveThoseThreeEuros = youOweMeThreeEuros.Negate();
    Assert.That(nowIHaveThoseThreeEuros, isMoneyWith(3m, CurrencyIsoCode.EUR));

    Money youOweMeThreeEurosAgain = -nowIHaveThoseThreeEuros;
    Assert.That(youOweMeThreeEurosAgain, isMoneyWith(-3m, CurrencyIsoCode.EUR));
}
</pre>
<p>And since a complete set of operations to be performed on moneys is difficult to 
	foresee, there are some simple extensibility points.</p>
<pre lang="C#">
[Test]
public void basic_arithmetic_operations_can_be_extended()
{
    Money halfMyDebt = -60m.Eur().Perform(amt =&gt; amt / 2);
    Assert.That(halfMyDebt, isMoneyWith(-30m, CurrencyIsoCode.EUR));

    Money convolutedWayToCancelDebt = (-50m).Eur().Perform(-1m.Eur(),
        (amt1, amt2) =&gt; decimal.Multiply(amt1, decimal.Negate(amt2)) - amt1);
    Assert.That(convolutedWayToCancelDebt, isMoneyWith(decimal.Zero, CurrencyIsoCode.EUR));
}
</pre>
<p>As with comparisons, it mostly makes sense to perform binary operations on moneys with the same currency.</p>
<pre lang="C#">
[Test]
public void binary_operations_only_possible_if_they_have_the_same_currency()
{
    Assert.That(() =&gt; 2m.Gbp().Minus(3m.Eur()), Throws.InstanceOf&lt;DifferentCurrencyException&gt;());
    Assert.That(() =&gt; 2m.Cad() + 3m.Aud(), Throws.InstanceOf&lt;DifferentCurrencyException&gt;());
    Assert.That(() =&gt; 3m.Usd().Perform(3m.Aud(), (x, y) =&gt; x + y), Throws.InstanceOf&lt;DifferentCurrencyException&gt;());
}
</pre>
<p>Most times it is more fun when two are involved, but a single money can do quite a few things on his own.</p>
<pre lang="C#">
[Test]
public void several_unary_operations_can_be_performed()
{
    Assert.That(3m.Xxx().Negate(), isMoneyWith(-3m), &quot;-1 * amount&quot;);
    Assert.That((-3m).Xxx().Abs(), isMoneyWith(3m), &quot;&#124;amount&#124;&quot;);

    Money twoThirds = new Money(2m / 3);
    Assert.That(twoThirds.Amount, Is.Not.EqualTo(0.66m), &quot;not exactly equals as it has more decimals&quot;);
    Assert.That(twoThirds.TruncateToSignificantDecimalDigits().Amount, Is.EqualTo(0.66m), &quot;XXX has two significant decimals&quot;);

    Money fractional = 123.456m.ToMoney();
    Assert.That(fractional.Truncate(), isMoneyWith(123m), &quot;whole amount&quot;);

    Assert.That(.5m.ToMoney().RoundToNearestInt(), isMoneyWith(0m));
    Assert.That(.599999m.ToMoney().RoundToNearestInt(), isMoneyWith(1m));
    Assert.That(1.5m.ToMoney().RoundToNearestInt(), isMoneyWith(2m));
    Assert.That(1.4999999m.ToMoney().RoundToNearestInt(), isMoneyWith(1m));

    Assert.That(.5m.ToMoney().RoundToNearestInt(MidpointRounding.ToEven), isMoneyWith(0m), &quot;closest even number is 0&quot;);
    Assert.That(.5m.ToMoney().RoundToNearestInt(MidpointRounding.AwayFromZero), isMoneyWith(1m), &quot;closest number away from zero is 1&quot;);
    Assert.That(1.5m.ToMoney().RoundToNearestInt(MidpointRounding.ToEven), isMoneyWith(2m), &quot;closest even number is 2&quot;);
    Assert.That(1.5m.ToMoney().RoundToNearestInt(MidpointRounding.AwayFromZero), isMoneyWith(2m), &quot;closest number away from zero is 2&quot;);

    Assert.That(2.345m.Usd().Round(), isMoneyWith(2.34m), &quot;round to two decimals&quot;);
    Assert.That(2.345m.Jpy().Round(), isMoneyWith(2m), &quot;round to no decimals&quot;);
    Assert.That(2.355m.Usd().Round(), isMoneyWith(2.36m), &quot;round to two decimals&quot;);
    Assert.That(2.355m.Jpy().Round(), isMoneyWith(2m), &quot;round to no decimals&quot;);

    Assert.That(2.345m.Usd().Round(MidpointRounding.ToEven), isMoneyWith(2.34m));
    Assert.That(2.345m.Usd().Round(MidpointRounding.AwayFromZero), isMoneyWith(2.35m));
    Assert.That(2.345m.Jpy().Round(MidpointRounding.ToEven), isMoneyWith(2m));
    Assert.That(2.345m.Jpy().Round(MidpointRounding.AwayFromZero), isMoneyWith(2m));

    Assert.That(123.456m.ToMoney().Floor(), isMoneyWith(123m));
    Assert.That((-123.456m).ToMoney().Floor(), isMoneyWith(-124m));
}
</pre>

<h2>Wrap-up</h2>

<p>In this third part of the series, we have seen what <a href="http://code.google.com/p/nmoneys/">NMoneys</a> offers to model monetary quantities. Several ways of creating
instances, formatting their display and some other operations to be performed were showcased.</p>

<h2>Series Wrap-up</h2>

<p>I had several goals when writing this whole series. The main one was to raise the awareness of the <a href="http://code.google.com/p/nmoneys/">NMoneys</a> library, so that
more people casn benefit from its usage, and more importantly more people can <a href="http://code.google.com/p/nmoneys/wiki/Contribute">contribute</a>.</p>
<p>Contributions can come in several shapes, but mainly in two ways: new features for the library and more accurate information for the currency information. Both will be
more than welcome.</p>
<p>The other goal was to show some scenarios that make teh library compelling to use. Helping the potential user to become a real one.</p>
<p>I hope any of the goals is achieved. If not, I, for one, had lots of fun sharing this with you, guys.</p>

<h2>History</h2>

<p>07-May-2011 - Initial version</p>

<!-------------------------------    That's it!   --------------------------->
</body>

</html>

